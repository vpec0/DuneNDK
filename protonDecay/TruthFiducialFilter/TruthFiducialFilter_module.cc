
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "TTree.h"

#include <memory>

#include "lardataobj/Simulation/SimChannel.h"
#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"

#include <iostream>
#include <algorithm>

namespace dune {
  class TruthFiducialFilter;
}

class dune::TruthFiducialFilter : public art::EDFilter {
public:
  explicit TruthFiducialFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TruthFiducialFilter(TruthFiducialFilter const &) = delete;
  TruthFiducialFilter(TruthFiducialFilter &&) = delete;
  TruthFiducialFilter & operator = (TruthFiducialFilter const &) = delete;
  TruthFiducialFilter & operator = (TruthFiducialFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;
  void beginJob() override;

private:

  // Declare member data here.
  art::ServiceHandle<geo::Geometry> geom_;
  double depth_;
  double edgemax_;
  double emax_;
  double emin_;
  art::ServiceHandle<art::TFileService> tfs_;
  TTree* tree_;
  unsigned runid_;
  unsigned eventid_;
  double etotal_;
  double evert_;
  double ewithin_;
  double minz_;
  double maxz_;
  double miny_;
  double maxy_;

};


dune::TruthFiducialFilter::TruthFiducialFilter(fhicl::ParameterSet const & p):
  EDFilter(),
  depth_(p.get<double>("depth", 10.)),
  edgemax_(p.get<double>("edgemax", 5.)),
  emax_(p.get<double>("emax", 3000.)),
  emin_(p.get<double>("emin", 10.))
  
// Initialize member data here.
{
  minz_=maxz_=miny_=maxy_=0;
  for (geo::GeometryCore::TPC_iterator iTPC=geom_->begin_TPC(); iTPC!=geom_->end_TPC(); iTPC++)
    {
      geo::TPCGeo const& tpc=*iTPC;
      double yl=tpc.CenterY()-tpc.ActiveHalfHeight();
      double yh=tpc.CenterY()+tpc.ActiveHalfHeight();
      double zl=tpc.CenterZ()-(tpc.ActiveLength()/2);
      double zh=tpc.CenterZ()+(tpc.ActiveLength()/2);
      if (iTPC==geom_->begin_TPC())
	{
	  miny_=yl;
	  maxy_=yh;
	  minz_=zl;
	  maxz_=zh;
	}
      else
	{
	  if (yl<miny_)
	    miny_=yl;
	  if (yh>maxy_)
	    maxy_=yh;
	  if (zl<minz_)
	    minz_=zl;
	  if (zh>maxz_)
	    maxz_=zh;
	}
    }
  //  std::cout << "tpc extents: " << miny << ", " << maxy << ", " << minz << ", " << maxz << std::endl;
  
}

void dune::TruthFiducialFilter::beginJob()
{
  tree_=tfs_->make<TTree>("eedge", "energy desposition at tpc edge in y and z");
  tree_->Branch("run", &runid_, "run/i");
  tree_->Branch("event", &eventid_, "event/i");
  tree_->Branch("etotal", &etotal_, "etotal/D");
  tree_->Branch("evert", &evert_, "evert/D");
  tree_->Branch("ewithin", &ewithin_, "ewithin/D");

}
bool dune::TruthFiducialFilter::filter(art::Event & event)
{
  // Implementation of required member function here.
  art::Handle<std::vector<sim::SimChannel> > simchannels;
  event.getByLabel("largeant", simchannels);
  
  std::vector<sim::IDE> ides;
  for (auto const& simchannel:*simchannels)
    {
      if (geom_->SignalType(simchannel.Channel()) == geo::kCollection)
	{
	  for (auto const& tdcide:simchannel.TDCIDEMap())
	    {
	      //unsigned int tdc=tdcide.first;
	      auto const& idevec=tdcide.second;
	      for (auto const& ide:idevec)
		{
		  ides.push_back(ide);
		}
	    }
	}
    }

  runid_=event.run();
  eventid_=event.event();
  double eleft=0, eright=0, etop=0, ebottom=0;
  etotal_=0;
  ewithin_=0;
  for (auto const& ide:ides)
    {
      double pos[3];
      pos[0]=ide.x;
      pos[1]=ide.y;
      pos[2]=ide.z;
      geo::TPCID tpcid=geom_->FindTPCAtPosition(pos);
      geo::GeometryCore::TPC_iterator iTPC = geom_->begin_TPC(),
	tend = geom_->end_TPC();
      geo::TPCGeo const* tpc=nullptr;
      while (iTPC != tend && !tpc) {
	if (iTPC.ID()==tpcid)
	  tpc=&(*iTPC);
	++iTPC;
      }
      if (tpc)
	{
       double lpos[3];
       tpc->WorldToLocalVect(pos, lpos);
       double totop=tpc->ActiveHalfHeight()-(pos[1]-tpc->CenterY());
       double tobottom=tpc->ActiveHalfHeight()-(tpc->CenterY()-pos[1]);
       double toright=(tpc->ActiveLength()/2)-(pos[2]-tpc->CenterZ());
       double toleft=(tpc->ActiveLength()/2)-(tpc->CenterZ()-pos[2]);
       bool top=(totop<depth_) && (tpc->CenterY()+tpc->ActiveHalfHeight()+0.1>=maxy_);
       bool bottom=(tobottom<depth_) && (tpc->CenterY()-tpc->ActiveHalfHeight()-0.1<=miny_);
       bool left=(toleft<=depth_) && (tpc->CenterZ()-tpc->ActiveLength()/2.-0.1<=minz_);
       bool right=(toright<=depth_) && (tpc->CenterZ()+tpc->ActiveLength()/2.+0.1>=maxz_);
       if (top || bottom || left || right)
	 {
	   etotal_+=ide.energy;
	   if (top) {
	     etop+=ide.energy;
	   }
	   if (bottom) {
	     ebottom+=ide.energy;
	   }
	   if (left) {
	     eleft+=ide.energy;
	   }
	   if (right) {
	     eright+=ide.energy;
	   }
	 }
       else 
	 ewithin_+=ide.energy;
	}
       //       std::cout << totop << ", " << tobottom << ", " << toleft << ", " << toright << std::endl;
      //    std::cout << lpos[1] << " (" << tpc->CenterY() << "±" << tpc->ActiveHalfHeight() <<"), " << lpos[2] << " (" << tpc->CenterZ() << "±" << (tpc->ActiveLength()/2.) << ")" << std::endl;
      //actiuvehalfheight for y and activelength for z
    }
  evert_=etop+ebottom;
  //  std::cout << etotal_ << " (" << evert_ << "), outside: " << ewithin_ << "\n";
  tree_->Fill();
  double eall=etotal_+ewithin_;
  if (etotal_>edgemax_ || eall>emax_ || eall<emin_)
     return false;
  else
     return true;
}

DEFINE_ART_MODULE(dune::TruthFiducialFilter)
